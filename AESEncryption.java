import java.util.Arrays;


/**
 * 
 * @author terry
 *Practice with AES 128bit encryption algorithm
 *
 */

public class cchen18PA4 {

	
private static int[][] key;
private static int[][] originalKey;
public static void main (String[] args) {
	String message = "PROGRAMMINGASSIGNMENT4";
	String[][] ciphertext = encryptionAES(message);
	decryptionAES(ciphertext);
	
	
}

/*This method handles splitting and padding messages
 * each split is then send to AES single block (128 bit) encryption process
 * The keys are generated and used as global variable
 * Same key is copied to a different variable to represent shared key. i.e both encryption and decryption process can expand and derive same key sets
 * The method calls encryptSingleBlock to encrypt the message*/

private static String[][] encryptionAES(String message){
	String [][] ciphertext = new String[message.length()/16+1][16];
	String[] whileMessage= new String[message.length()/16+1];
	for(int i=0;i<message.length();i+=16) {
		if(message.substring(i).length()<16) {
			String x = message.substring(i);
			while(x.length()<16) {
				x=x+"*";
			}
			whileMessage[i/16]=x;
		}
		else {
			whileMessage[i/16]=message.substring(i,i+16);
		}	
		
	}
	
	originalKey = generateKey();
	key =originalKey.clone();
	for(int i=0;i<whileMessage.length;i++) {
		ciphertext[i]=encryptSingleBlock(whileMessage[i]);
	}
	
	return ciphertext;
	
}



/*This method decrypts messages
 * each message then send to AES single block (128 bit) decryption process
 * after decryption, the method prints the orignal message, including the padded characters
 * The method calls decryptSingleBlock to decrypt the message*/
private static String[][] decryptionAES(String [][] cyphertext){
	String[][] originalMessage = new String[cyphertext.length][16];
	for(int i=0;i<cyphertext.length;i++) {
			originalMessage[i]=decryptSingleBlock(cyphertext[i]);
	}
	
	for(int i=0;i<originalMessage.length;i++) {
		for(int j=0;j<originalMessage[i].length;j++) {
			System.out.print(originalMessage[i][j]);
		}
	}
	System.out.println();
return originalMessage;
}

/*This method encrypts 128 bit block.
 * generateStates method encodes the message and transpose the matrix to match AES states format. i.e states are filled from top to bottom, then left to right.
 * It expands the keys for all 11 rounds in the beginning to reduce intermediate computation, the expanded key is a 4*44 matrix
 * getExpandedKeySection retrieves a required section from the expanded key set, i.e a 4*4 matrix from 0 to 3, 4 to 7, and so on
 * addKeyRound changes the message(states) by XORing the states with the current key set. Key sets are changed based on round number. round 1 starts from column 4 to column 7
 * subByte changes the states based on Rijndael S-box.
 * shiftRow changes the position of the matrix
 * mixColumn includes a combination of XOR operations with matrix multiplication. In this program, look up tables are used to save implementation time.
 * For 128bit AES algorithm, there will be 10 rounds of encryption process. Based on round number, some methods will not be used in specific rounds. (extra methods outside of the for loop)
 * This method outputs an array of encrypted message(states) fragments from the plaintext. The fragments can be decrypted to form original message
 * 
 */
private static String[] encryptSingleBlock(String plaintext) {

	String[] states = generateStates(plaintext);
	System.out.println("Message :"+ Arrays.toString(states));
	int[][] expandedKeys = keyExpansion(key);
	int [][] key2= getExpandedKeySection(expandedKeys,1);
	int[][] newState= addRoundKey(states,key2);
	states= convert2DToArray(newState);
	System.out.println(Arrays.toString(states));
	for(int i=1;i<10;i++) {
		subByte(states);
		shiftRow(states);
		mixColumn(states);
		key2= getExpandedKeySection(expandedKeys,i);
		newState= addRoundKey(states,key2);
		states= convert2DToArray(newState);
		System.out.println(Arrays.toString(states));
	}
	subByte(states);
	shiftRow(states);
	key2= getExpandedKeySection(expandedKeys,10);
	newState= addRoundKey(states,key2);
	states= convert2DToArray(newState);
	System.out.println();
	System.out.println("Encrypted to: "+Arrays.toString(states));
	System.out.println();
	
	return states;
}

/*This method decrypts 128 bit block.
 * It expands the keys for all 11 rounds in the beginning to reduce intermediate computation, the expanded key is a 4*44 matrix
 * getExpandedKeySection retrieves a required section from the expanded key set, i.e a 4*4 matrix from 0 to 3, 4 to 7, and so on
 * addKeyRound changes the message(states) by XORing the states with the current key set. With correct key set, XOR operation can generate original message.
 * inverseSubByte reverses the states based on Rijndael's inverse S-box.
 * inverseShiftRow changes the position of the matrix, restore the rows and columns to where they were before. 
 * inverseMixColumn includes a combination of XOR operations with matrix multiplication. With Rijndael's inverse mixColumn, XOR operation can restore the original message 
 * This method outputs an array of encrypted message(states) fragments from the plaintext. The fragments can be decrypted to form original message
 * For 128bit AES algorithm, the decrytion process has to repeat 9 rounds with extra methods to fully decrpyt the states.
 * reverseStates method decodes the message and transpose the matrix to English text message
 * The method generates a array of plaintext message, each element represent 1 word.
 */
private static String[] decryptSingleBlock(String[] ciphertext) {
	int[][] expandedKeys = keyExpansion(originalKey);
	System.out.println();
	System.out.println("Decrypted from: "+Arrays.toString(ciphertext));
	System.out.println();
	
	int [][] key2= getExpandedKeySection(expandedKeys,10);
	int[][] newState= addRoundKey(ciphertext,key2);
	String[] states= convert2DToArray(newState);
	inverseShiftRow(states);
	inverseSubByte(states);

	System.out.println(Arrays.toString(states));
	for(int i=9;i>=1;i--) {
		key2= getExpandedKeySection(expandedKeys,i);
		newState= addRoundKey(states,key2);
		states= convert2DToArray(newState);
		inverseMixColumn(states);
		inverseShiftRow(states);
		inverseSubByte(states);
		System.out.println(Arrays.toString(states));
		
	}
	key2= getExpandedKeySection(expandedKeys,1);
	newState= addRoundKey(states,key2);
	states= convert2DToArray(newState);
	System.out.println(Arrays.toString(states));
	
	String[] originalMessage= reverseStates(states);

	return originalMessage;
	

	
}
/*
 * This method generates a random 4*4 matrix, each element ranges from 1 to 256, to represent the secret key.
 */
private static int[][] generateKey() {
	//String[][] result = new String[4][4];
	int[][] result = new int[4][4];
	try {
		for(int i=0;i<result.length;i++) {
			for(int j=0;j<result[i].length;j++) {
				result[i][j]=generateRandomHex();
			}
		}


	}
	catch(Exception ex) {
		System.out.println("Error generating key");
		ex.printStackTrace();
	}
	return result;
	//return 0.0;
}


/*
 * This method reads each character from the original message and encodes it to a 2 digit hex value
 * AES algorithm converts the mesasge into states, and fills state matrix from top to bottom, then left to right. This requires matrix transposition.
 * swapArrayItem() switches the array elements
 */
private static String[] generateStates(String message){
	String states[] = new String[16];
	for(int i=0;i<states.length;i++) {
		Character currentCharacter = message.charAt(i);
		states[i]=encodeCharacter(currentCharacter);
	}
	swapArrayItem(states,1,4);
	swapArrayItem(states,2,8);
	swapArrayItem(states,3,12);
	swapArrayItem(states,6,9);
	swapArrayItem(states,7,13);
	swapArrayItem(states,11,14);
	return states;
}

/*
 * This method reads each character in the String to decode the message from hex value to text.
 * swapArrayItem() switches the array elements back to original form
 */
private static String[] reverseStates(String [] ciphertext){
	String states[] = new String[16];
	for(int i=0;i<states.length;i++) {
		String currentCharacter = ciphertext[i];
		states[i]=decodeCharacter(currentCharacter);
	}
	swapArrayItem(states,1,4);
	swapArrayItem(states,2,8);
	swapArrayItem(states,3,12);
	swapArrayItem(states,6,9);
	swapArrayItem(states,7,13);
	swapArrayItem(states,11,14);
	return states;
}


private static int generateRandomHex() {
	String hex=Integer.toHexString((int) (Math.random()*Math.pow(2, 8)));
	return Integer.parseInt(hex,16);
	
	
}
/*
 * This method converts the state matrix with different states based on Rijndael S-box.
 * This getSBox() retrieves the entire look-up table for state conversion.
 * In case if there is only 1 hex digit instead of 2, the first digit is assumed to be 0
 */


private static void subByte(String[] input) {
	String[] s = getSBox();
	for(int i=0;i<input.length;i++) {
		if(input[i].length()==1) {
			Integer temp = 0;
			Integer temp2 = sboxConversion(input[i].charAt(0));
			String value = s[temp*16+temp2].substring(2);
			input [i]= value;
		}
		else {
			Integer temp = sboxConversion(input[i].charAt(0));
			Integer temp2 = sboxConversion(input[i].charAt(1));
			String value = s[temp*16+temp2].substring(2);
			input [i]= value;
		}

		
	}
	
}

/*
 * This method converts restores state matrix to its previous state based on Rijndael inverse S-box.
 * This getInverseSBox() retrieves the entire look-up table for state conversion.
 * In case if there is only 1 hex digit instead of 2, the first digit is assumed to be 0
 */
private static void inverseSubByte(String[] input) {
	String [] s = getInverseSBox();
	for(int i=0;i<input.length;i++) {
		if(input[i].length()==1) {
			Integer temp = 0;
			Integer temp2 = sboxConversion(input[i].charAt(0));
			String value = s[temp*16+temp2].substring(2);
			input [i]= value;
		}
		else {
			Integer temp = sboxConversion(input[i].charAt(0));
			Integer temp2 = sboxConversion(input[i].charAt(1));
			String value = s[temp*16+temp2].substring(2);
			input [i]= value;
		}

		
	}
	
	
	
}


/*
 * This method changes shifts the state matrix's, first row unchanged, 2nd row shifts to the left by 1 and 3rd row shifts to the left by 2 and last row shifts to the left by 3.  
 */
private static void shiftRow(String[] input) {
	for(int i =0;i<input.length;i+=4) {
		if(i<=3) {
			
		}
		else {
			String temp = input[i];
			input[i]=input[i+1];
			input[i+1]=input[i+2];
			input[i+2]=input[i+3];
			input[i+3]=temp;
		}
		
	}
		
}
/*
 * This method reverses the shifts of state matrix's, first row unchanged, 2nd row shifts to the right by 1 and 3rd row shifts to the right by 2 and last row shifts to the right by 3.  
 */
private static void inverseShiftRow(String[] input) {
	for(int i =0;i<input.length;i+=4) {
		if(i<=3) {
			
		}
		else {
			String temp = input[i+3];
			input[i+3]=input[i+2];
			input[i+2]=input[i+1];
			input[i+1]=input[i];
			input[i]=temp;
		}	
	}
	
}
/*
 * This method changes the state matrix based on Rijndael MixColumns.
 * The states are changed through a combination of XOR process following the order of matrix multiplication.
 * getMul2Table()/getMul3Table() retrives the lookup table
 * using the matrix from Rijndael MixColumns, each row in the fixedMatrix has to multiply each column of the state matrix to generate new state matrix. 
 * The multiplication "is not" arithmetic, and requires table loop up such as mul2[<value>] to get 2*[<state matrix value>]
 * The addition "is not" arithmetic, it is done by XORing all the values.
 *  
 */
private static void mixColumn(String[] input) {
	int[][] fixedMatrix = {{2,3,1,1},{1,2,3,1},{1,1,2,3},{3,1,1,2}};
	String[][] input2DArray = new String [4][4];
	String [][]result= new String [4][4];
	int[] mul2 = getMul2Table();
	int[] mul3 = getMul3Table();
	for(int i=0;i<input2DArray.length;i++) {
		for(int j=0;j<input2DArray.length;j++) {
			input2DArray[i][j]=input[i*4+j];
			//System.out.print(input2DArray[i][j]+",");
		}
	}			
	
		for(int i =0;i<4;i++) {
			Integer temp=mul2[Integer.parseInt(input2DArray[0][i],16)]^mul3[Integer.parseInt(input2DArray[1][i],16)]^Integer.parseInt(input2DArray[2][i],16)^Integer.parseInt(input2DArray[3][i],16);		
			result[0][i]= Integer.toHexString(temp).toUpperCase();

			temp=Integer.parseInt(input2DArray[0][i],16)^mul2[Integer.parseInt(input2DArray[1][i],16)]^mul3[Integer.parseInt(input2DArray[2][i],16)]^Integer.parseInt(input2DArray[3][i],16);		
			result[1][i]= Integer.toHexString(temp).toUpperCase();

			temp=Integer.parseInt(input2DArray[0][i],16)^Integer.parseInt(input2DArray[1][i],16)^mul2[Integer.parseInt(input2DArray[2][i],16)]^mul3[Integer.parseInt(input2DArray[3][i],16)];		
			result[2][i]= Integer.toHexString(temp).toUpperCase();

			temp=mul3[Integer.parseInt(input2DArray[0][i],16)]^Integer.parseInt(input2DArray[1][i],16)^Integer.parseInt(input2DArray[2][i],16)^mul2[Integer.parseInt(input2DArray[3][i],16)];		
			result[3][i]= Integer.toHexString(temp).toUpperCase();

		}		
		
		for(int i=0;i<result.length;i++) {
			for(int j=0;j<result.length;j++) {
				input[i*result.length+j]=result[i][j];
			}
		}	

}
/*
 * This method restores the state matrix to the previous state on Rijndael inverse MixColumns.
 * The states are changed through a combination of XOR process following the order of matrix multiplication.
 * getMul9Table()/getMul11Table()//getMul13Table()/getMul14Table() retrives the lookup tables
 * using the inverse matrix from Rijndael MixColumns, each row in the fixedMatrix has to multiply each column of the state matrix to generate previous state matrix. 
 * The multiplication "is not" arithmetic, and requires table loop up such as mul2[<value>] to get 2*[<state matrix value>]
 * The addition "is not" arithmetic, it is done by XORing all the values.
 *  
 */
private static void inverseMixColumn(String[] input) {
	int[][] fixedMatrix = {{14,11,13,9},{9,14,11,13},{13,9,14,11},{11,13,9,14}};
	String[][] input2DArray = new String [4][4];
	String [][]result= new String [4][4];
	int[] mul9 = getMul9Table();
	int[] mul11 = getMul11Table();
	int[] mul13 = getMul13Table();
	int[] mul14 = getMul14Table();
	
	for(int i=0;i<input2DArray.length;i++) {
		for(int j=0;j<input2DArray.length;j++) {
			input2DArray[i][j]=input[i*4+j];
			
		}
	}			
	
		for(int i =0;i<4;i++) {
			Integer temp=mul14[Integer.parseInt(input2DArray[0][i],16)]^mul11[Integer.parseInt(input2DArray[1][i],16)]^mul13[Integer.parseInt(input2DArray[2][i],16)]^mul9[Integer.parseInt(input2DArray[3][i],16)];		
			result[0][i]= Integer.toHexString(temp).toUpperCase();
			//System.out.print(Integer.toHexString(temp));
			temp=mul9[Integer.parseInt(input2DArray[0][i],16)]^mul14[Integer.parseInt(input2DArray[1][i],16)]^mul11[Integer.parseInt(input2DArray[2][i],16)]^mul13[Integer.parseInt(input2DArray[3][i],16)];		
			result[1][i]= Integer.toHexString(temp).toUpperCase();;
			temp=mul13[Integer.parseInt(input2DArray[0][i],16)]^mul9[Integer.parseInt(input2DArray[1][i],16)]^mul14[Integer.parseInt(input2DArray[2][i],16)]^mul11[Integer.parseInt(input2DArray[3][i],16)];		
			result[2][i]= Integer.toHexString(temp).toUpperCase();;
			temp=mul11[Integer.parseInt(input2DArray[0][i],16)]^mul13[Integer.parseInt(input2DArray[1][i],16)]^mul9[Integer.parseInt(input2DArray[2][i],16)]^mul14[Integer.parseInt(input2DArray[3][i],16)];		
			result[3][i]= Integer.toHexString(temp).toUpperCase();;
		}		
		
		for(int i=0;i<result.length;i++) {
			for(int j=0;j<result.length;j++) {
				input[i*result.length+j]=result[i][j];
			}
		}	
}
private static int[][] addRoundKey(String[] states, int[][] keys) {
	int [][] state2DArray =new int [4][4];
	for (int i=0;i<4;i++) {
		for (int j=0;j<4;j++) {
			state2DArray[i][j]=Integer.parseInt(states[i*4+j],16);
		}	
	}
	for (int i=0;i<4;i++) {
		for (int j=0;j<4;j++) {
			state2DArray[i][j]=state2DArray[i][j]^keys[i][j];
		}	
	}
	return state2DArray;
}

/*The keyExpansion method expands existing 128 bit key matrix from 4*4 matrix to 4*44 matrix
 * The generateRoundKey method performs key calculation, and generates a 4*4 key matrix based on previous 4*4 matrix
 * Both the original, and generated key matrices are concatenated, eventually, this forms a 4*44 matrix for key lookup.
 * */
private static int[][] keyExpansion(int[][] key){
	int[][] expandedKeys = new int [4][44];
	int[][] temp = key;
	
	for(int i=0;i<44;i+=4) {
		if(i<4) {
			for(int j=0;j<temp.length;j++) {
				for(int k=0;k<temp.length;k++) {
					expandedKeys[j][k]=temp[j][k];
				}
			}
		}
		else
		{
			temp=generateRoundKey(temp,i/4);	
		}
		for(int j=0;j<temp.length;j++) {
			for(int k=0;k<temp.length;k++) {
				expandedKeys[j][i+k]=temp[j][k];
			}
		}
	}

			
	return expandedKeys;
}

/*The generateRoundKey method generates a new key matrix based on previous 4*4 matrix.
 * Based on Rijndael key schedule, every 4th key column must be calculated with a scheme
 * The scheme includes rotating one key matrix column (shift left or shift up), substitute the key value with s-box, and multiply by single column generated from the key schedule based on round number
 * The column generated by the scheme is then XORed with the first column in the previous round.
 * for every 1st,2nd,3rd column, the key column is generated by XORing the same key column from the previous round.
 * The addRoundKey() method XORs the state matrix with different 4*4 key matrices, therefore, with same 4*4 key set, the previous state matrix can be obtained.
 */
private static int[][] generateRoundKey(int[][] key, int roundNumber) {
	
	int[][] input2DArray = key;
//	int[][] input2DArray = new int[4][4];
	int[][] newKeys = new int [4][4];
//	for(int i=0;i<input2DArray.length;i++) {
//		for(int j=0;j<input2DArray.length;j++) {
//			input2DArray[i][j]=(key[i*4+j]);
//		}
//	}
	int[][] words =new int[key.length/4*11][4];
	//Basic keys
	for(int i=0;i<input2DArray.length;i++) {
		int[] singleWord = new int[4];
		for(int j=0;j<input2DArray.length;j++) {
			singleWord[j]=input2DArray[j][i];
		}
		words[i][0]=singleWord[0];
		words[i][1]=singleWord[1];
		words[i][2]=singleWord[2];
		words[i][3]=singleWord[3];
	}	
	
	int temp = words[3][0];
	words[3][0]=words[3][1];
	words[3][1]=words[3][2];
	words[3][2]=words[3][3];
	words[3][3]=temp;
	
	String[] sbox= getSBox();

	words[3][0]=Integer.parseInt(sbox[words[3][0]].substring(2),16);
	words[3][1]=Integer.parseInt(sbox[words[3][1]].substring(2),16);
	words[3][2]=Integer.parseInt(sbox[words[3][2]].substring(2),16);
	words[3][3]=Integer.parseInt(sbox[words[3][3]].substring(2),16);
	
	temp = words[3][0]^roundMatrixLookUp(roundNumber); 
	
	newKeys[0][0]=words[0][0]^temp;
	newKeys[0][1]=words[0][1]^words[3][1];	
	newKeys[0][2]=words[0][2]^words[3][2];
	newKeys[0][3]=words[0][3]^words[3][3];

	newKeys[1][0]=words[1][0]^newKeys[0][0];
	newKeys[1][1]=words[1][1]^newKeys[0][1];
	newKeys[1][2]=words[1][2]^newKeys[0][2];
	newKeys[1][3]=words[1][3]^newKeys[0][3];
	
	newKeys[2][0]=words[2][0]^newKeys[1][0];
	newKeys[2][1]=words[2][1]^newKeys[1][1];
	newKeys[2][2]=words[2][2]^newKeys[1][2];
	newKeys[2][3]=words[2][3]^newKeys[1][3];
	
	newKeys[3][0]=words[3][0]^newKeys[2][0];
	newKeys[3][1]=words[3][1]^newKeys[2][1];
	newKeys[3][2]=words[3][2]^newKeys[2][2];
	newKeys[3][3]=words[3][3]^newKeys[2][3];
	
	return newKeys;
}
private static String[] getSBox() {
	String[] sbox = {
		    "0x63", "0x7C", "0x77", "0x7B", "0xF2", "0x6B", "0x6F", "0xC5", "0x30", "0x01", "0x67", "0x2B", "0xFE", "0xD7", "0xAB", "0x76",
		    "0xCA", "0x82", "0xC9", "0x7D", "0xFA", "0x59", "0x47", "0xF0", "0xAD", "0xD4", "0xA2", "0xAF", "0x9C", "0xA4", "0x72", "0xC0",
		    "0xB7", "0xFD", "0x93", "0x26", "0x36", "0x3F", "0xF7", "0xCC", "0x34", "0xA5", "0xE5", "0xF1", "0x71", "0xD8", "0x31", "0x15",
		    "0x04", "0xC7", "0x23", "0xC3", "0x18", "0x96", "0x05", "0x9A", "0x07", "0x12", "0x80", "0xE2", "0xEB", "0x27", "0xB2", "0x75",
		    "0x09", "0x83", "0x2C", "0x1A", "0x1B", "0x6E", "0x5A", "0xA0", "0x52", "0x3B", "0xD6", "0xB3", "0x29", "0xE3", "0x2F", "0x84",
		    "0x53", "0xD1", "0x00", "0xED", "0x20", "0xFC", "0xB1", "0x5B", "0x6A", "0xCB", "0xBE", "0x39", "0x4A", "0x4C", "0x58", "0xCF",
		    "0xD0", "0xEF", "0xAA", "0xFB", "0x43", "0x4D", "0x33", "0x85", "0x45", "0xF9", "0x02", "0x7F", "0x50", "0x3C", "0x9F", "0xA8",
		    "0x51", "0xA3", "0x40", "0x8F", "0x92", "0x9D", "0x38", "0xF5", "0xBC", "0xB6", "0xDA", "0x21", "0x10", "0xFF", "0xF3", "0xD2",
		    "0xCD", "0x0C", "0x13", "0xEC", "0x5F", "0x97", "0x44", "0x17", "0xC4", "0xA7", "0x7E", "0x3D", "0x64", "0x5D", "0x19", "0x73",
		    "0x60", "0x81", "0x4F", "0xDC", "0x22", "0x2A", "0x90", "0x88", "0x46", "0xEE", "0xB8", "0x14", "0xDE", "0x5E", "0x0B", "0xDB",
		    "0xE0", "0x32", "0x3A", "0x0A", "0x49", "0x06", "0x24", "0x5C", "0xC2", "0xD3", "0xAC", "0x62", "0x91", "0x95", "0xE4", "0x79",
		    "0xE7", "0xC8", "0x37", "0x6D", "0x8D", "0xD5", "0x4E", "0xA9", "0x6C", "0x56", "0xF4", "0xEA", "0x65", "0x7A", "0xAE", "0x08",
		    "0xBA", "0x78", "0x25", "0x2E", "0x1C", "0xA6", "0xB4", "0xC6", "0xE8", "0xDD", "0x74", "0x1F", "0x4B", "0xBD", "0x8B", "0x8A",
		    "0x70", "0x3E", "0xB5", "0x66", "0x48", "0x03", "0xF6", "0x0E", "0x61", "0x35", "0x57", "0xB9", "0x86", "0xC1", "0x1D", "0x9E",
		    "0xE1", "0xF8", "0x98", "0x11", "0x69", "0xD9", "0x8E", "0x94", "0x9B", "0x1E", "0x87", "0xE9", "0xCE", "0x55", "0x28", "0xDF",
		    "0x8C", "0xA1", "0x89", "0x0D", "0xBF", "0xE6", "0x42", "0x68", "0x41", "0x99", "0x2D", "0x0F", "0xB0", "0x54", "0xBB", "0x16"
	};
	return sbox;
}

private static String[] getInverseSBox() {
	String[] iSBox= {
    "0x52", "0x09", "0x6A", "0xD5", "0x30", "0x36", "0xA5", "0x38", "0xBF", "0x40", "0xA3", "0x9E", "0x81", "0xF3", "0xD7", "0xFB",
    "0x7C", "0xE3", "0x39", "0x82", "0x9B", "0x2F", "0xFF", "0x87", "0x34", "0x8E", "0x43", "0x44", "0xC4", "0xDE", "0xE9", "0xCB",
    "0x54", "0x7B", "0x94", "0x32", "0xA6", "0xC2", "0x23", "0x3D", "0xEE", "0x4C", "0x95", "0x0B", "0x42", "0xFA", "0xC3", "0x4E",
    "0x08", "0x2E", "0xA1", "0x66", "0x28", "0xD9", "0x24", "0xB2", "0x76", "0x5B", "0xA2", "0x49", "0x6D", "0x8B", "0xD1", "0x25",
    "0x72", "0xF8", "0xF6", "0x64", "0x86", "0x68", "0x98", "0x16", "0xD4", "0xA4", "0x5C", "0xCC", "0x5D", "0x65", "0xB6", "0x92",
    "0x6C", "0x70", "0x48", "0x50", "0xFD", "0xED", "0xB9", "0xDA", "0x5E", "0x15", "0x46", "0x57", "0xA7", "0x8D", "0x9D", "0x84",
    "0x90", "0xD8", "0xAB", "0x00", "0x8C", "0xBC", "0xD3", "0x0A", "0xF7", "0xE4", "0x58", "0x05", "0xB8", "0xB3", "0x45", "0x06",
    "0xD0", "0x2C", "0x1E", "0x8F", "0xCA", "0x3F", "0x0F", "0x02", "0xC1", "0xAF", "0xBD", "0x03", "0x01", "0x13", "0x8A", "0x6B",
    "0x3A", "0x91", "0x11", "0x41", "0x4F", "0x67", "0xDC", "0xEA", "0x97", "0xF2", "0xCF", "0xCE", "0xF0", "0xB4", "0xE6", "0x73",
    "0x96", "0xAC", "0x74", "0x22", "0xE7", "0xAD", "0x35", "0x85", "0xE2", "0xF9", "0x37", "0xE8", "0x1C", "0x75", "0xDF", "0x6E",
    "0x47", "0xF1", "0x1A", "0x71", "0x1D", "0x29", "0xC5", "0x89", "0x6F", "0xB7", "0x62", "0x0E", "0xAA", "0x18", "0xBE", "0x1B",
    "0xFC", "0x56", "0x3E", "0x4B", "0xC6", "0xD2", "0x79", "0x20", "0x9A", "0xDB", "0xC0", "0xFE", "0x78", "0xCD", "0x5A", "0xF4",
    "0x1F", "0xDD", "0xA8", "0x33", "0x88", "0x07", "0xC7", "0x31", "0xB1", "0x12", "0x10", "0x59", "0x27", "0x80", "0xEC", "0x5F",
    "0x60", "0x51", "0x7F", "0xA9", "0x19", "0xB5", "0x4A", "0x0D", "0x2D", "0xE5", "0x7A", "0x9F", "0x93", "0xC9", "0x9C", "0xEF",
    "0xA0", "0xE0", "0x3B", "0x4D", "0xAE", "0x2A", "0xF5", "0xB0", "0xC8", "0xEB", "0xBB", "0x3C", "0x83", "0x53", "0x99", "0x61",
    "0x17", "0x2B", "0x04", "0x7E", "0xBA", "0x77", "0xD6", "0x26", "0xE1", "0x69", "0x14", "0x63", "0x55", "0x21", "0x0C", "0x7D"};
	
	return iSBox;
}
private static int[][] getExpandedKeySection(int[][] expandedKeys, int roundNumber){
	
	int[][] section = new int[4][4];
	for(int i =0;i<4;i++) {
		for(int j=0;j<4;j++) {
			section[i][j]=expandedKeys[i][roundNumber*4+j];
		}
	}
	return section;
}
private static int[] getMul2Table() {
	int[] mul2= 
		{0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
			0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
			0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
			0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
			0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
			0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
			0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
			0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
			0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
			0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
			0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
			0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
			0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
			0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
			0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
			0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5};
	return mul2;
}
private static int[] getMul3Table() {
	int[] mul3= {0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
			0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
			0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
			0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
			0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
			0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
			0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
			0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
			0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
			0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
			0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
			0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
			0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
			0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
			0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
			0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a};
	return mul3;
}
private static int[] getMul9Table() {
	int[] mul9= {0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
			0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
			0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
			0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
			0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
			0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
			0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
			0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
			0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
			0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
			0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
			0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
			0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
			0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
			0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
			0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46};
	return mul9;
}
private static int[] getMul11Table() {
	int[] mul11= {0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
			0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
			0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
			0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
			0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
			0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
			0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
			0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
			0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
			0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
			0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
			0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
			0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
			0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
			0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
			0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3};
	return mul11;
}
private static int[] getMul13Table() {
	int[] mul13= {0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
			0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
			0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
			0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
			0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
			0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
			0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
			0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
			0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
			0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
			0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
			0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
			0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
			0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
			0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
			0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97};
	return mul13;
}

private static int[] getMul14Table() {
	int[] mul14= {0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
			0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
			0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
			0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
			0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
			0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
			0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
			0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
			0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
			0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
			0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
			0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
			0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
			0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
			0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
			0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d};
	return mul14;
}
private static String[] convert2DToArray(int[][] ary){
	String [] array = new String[16];
	for(int i=0;i<ary.length;i++)
		for(int j=0;j<ary.length;j++) {
			array[i*4+j]=Integer.toHexString(ary[i][j]).toUpperCase();
		}
	
	return array;
}
/*This method swaps different elements in the matrix*/
private static void swapArrayItem(String[] ary, int source, int dest) {
	String temp = ary[source];
	ary[source] = ary[dest];
	ary[dest] = temp;
}
/*This method is used to expand the 128 bit key, Rijndael's key schedule has the entire table, however, 128 bit key only require 10 rounds or permutation, only 10 values from the table is required
 * Based on different round number, different 4*1 columns can be generated. This column is part of the XOR operation to generate a new round of keys.*/

private static int roundMatrixLookUp(int roundNumber) {
	int  result = 0;
	switch(roundNumber){
		case 1:
			result = 1;
		break;
		case 2:
			result = 2;
		break;
		case 3:
			result = 4;
		break;
		case 4:
			result = 8;
		break;
		case 5:
			result = 0x10;
		break;
		case 6:
			result = 0x20;
		break;
		case 7:
			result = 0x40;
		break;
		case 8:
			result = 0x80;
		break;
		case 9:
			result = 0x36;
		break;
		case 10:
			result = 0x6c;
		break;
		default:
			result=-1;
			break;
		
	}

	return result;
	
}
private static Integer sboxConversion(Character c) {
	Integer result=0;
	switch(String.valueOf(c)) {
		case "0":
			result=0;
			break;	
		case "1":
			result=1;
			break;
		case "2":
			result=2;
			break;
		case "3":
			result=3;
			break;
		case "4":
			result=4;
			break;
		case "5":
			result=5;
			break;
		case "6":
			result=6;
			break;
		case "7":
			result=7;
			break;
		case "8":
			result=8;
			break;
		case "9":
			result=9;
			break;			
		case "A":
			result=10;
			break;
		case "B":
			result=11;
			break;
		case "C":
			result=12;
			break;
		case "D":
			result=13;
			break;
		case "E":
			result=14;
			break;
		case "F":
			result=15;
			break;			
	}
	return result;
}
/*This method encodes the original message into hex values to generate states*/
private static String encodeCharacter(Character c) {
	if (String.valueOf(c).equals("A"))
		return "00";
	else if (String.valueOf(c).equals("B"))
		return "01";
	else if (String.valueOf(c).equals("C"))
		return "02";
	else if (String.valueOf(c).equals("D"))
		return "03";
	else if (String.valueOf(c).equals("E"))
		return "04";
	else if (String.valueOf(c).equals("F"))
		return "05";
	else if (String.valueOf(c).equals("G"))
		return "06";
	else if (String.valueOf(c).equals("H"))
		return "07";
	else if (String.valueOf(c).equals("I"))
		return "08";
	else if (String.valueOf(c).equals("J"))
		return "09";
	else if (String.valueOf(c).equals("K"))
		return "0A";
	else if (String.valueOf(c).equals("L"))
		return "0B";
	else if (String.valueOf(c).equals("M"))
		return "0C";
	else if (String.valueOf(c).equals("N"))
		return "0D";
	else if (String.valueOf(c).equals("O"))
		return "0E";
	else if (String.valueOf(c).equals("P"))
		return "0F";
	else if (String.valueOf(c).equals("Q"))
		return "10";
	else if (String.valueOf(c).equals("R"))
		return "11";
	else if (String.valueOf(c).equals("S"))
		return "12";
	else if (String.valueOf(c).equals("T"))
		return "13";
	else if (String.valueOf(c).equals("U"))
		return "14";
	else if (String.valueOf(c).equals("V"))
		return "15";
	else if (String.valueOf(c).equals("W"))
		return "16";
	else if (String.valueOf(c).equals("X"))
		return "17";		
	else if (String.valueOf(c).equals("Y"))
		return "18";		
	else if (String.valueOf(c).equals("Z"))
		return "19";		
	else if (String.valueOf(c).equals("1"))
		return "1A";		
	else if (String.valueOf(c).equals("2"))
		return "1B";		
	else if (String.valueOf(c).equals("3"))
		return "1C";		
	else if (String.valueOf(c).equals("4"))
		return "1D";		
	else if (String.valueOf(c).equals("5"))
		return "1E";				
	else if (String.valueOf(c).equals("6"))
		return "1F";						
	else if (String.valueOf(c).equals("7"))
		return "20";		
	else if (String.valueOf(c).equals("8"))
		return "21";						
	else if (String.valueOf(c).equals("9"))
		return "22";	
	else if (String.valueOf(c).equals("*"))
		return "23";	
	else
		return "Error"; 
}
/*This method decodes thehex values to generate message*/
private static String decodeCharacter(String c) {
	if (String.valueOf(c).equals("0"))
		return "A";
	else if (String.valueOf(c).equals("1"))
		return "B";
	else if (String.valueOf(c).equals("2"))
		return "C";
	else if (String.valueOf(c).equals("3"))
		return "D";
	else if (String.valueOf(c).equals("4"))
		return "E";
	else if (String.valueOf(c).equals("5"))
		return "F";
	else if (String.valueOf(c).equals("6"))
		return "G";
	else if (String.valueOf(c).equals("7"))
		return "H";
	else if (String.valueOf(c).equals("8"))
		return "I";
	else if (String.valueOf(c).equals("9"))
		return "J";
	else if (String.valueOf(c).equals("A"))
		return "K";
	else if (String.valueOf(c).equals("B"))
		return "L";
	else if (String.valueOf(c).equals("C"))
		return "M";
	else if (String.valueOf(c).equals("D"))
		return "N";
	else if (String.valueOf(c).equals("E"))
		return "O";
	else if (String.valueOf(c).equals("F"))
		return "P";
	else if (String.valueOf(c).equals("10"))
		return "Q";
	else if (String.valueOf(c).equals("11"))
		return "R";
	else if (String.valueOf(c).equals("12"))
		return "S";
	else if (String.valueOf(c).equals("13"))
		return "T";
	else if (String.valueOf(c).equals("14"))
		return "U";
	else if (String.valueOf(c).equals("15"))
		return "V";
	else if (String.valueOf(c).equals("16"))
		return "W";
	else if (String.valueOf(c).equals("17"))
		return "X";		
	else if (String.valueOf(c).equals("18"))
		return "Y";		
	else if (String.valueOf(c).equals("19"))
		return "Z";		
	else if (String.valueOf(c).equals("1A"))
		return "1";		
	else if (String.valueOf(c).equals("1B"))
		return "2";		
	else if (String.valueOf(c).equals("1C"))
		return "3";		
	else if (String.valueOf(c).equals("1D"))
		return "4";		
	else if (String.valueOf(c).equals("1E"))
		return "5";				
	else if (String.valueOf(c).equals("1F"))
		return "6";						
	else if (String.valueOf(c).equals("20"))
		return "7";		
	else if (String.valueOf(c).equals("21"))
		return "8";						
	else if (String.valueOf(c).equals("22"))
		return "9";	
	else if (String.valueOf(c).equals("23"))
		return "*";
	else
		return "Error"; 
}
}


